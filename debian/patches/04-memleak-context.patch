Description: Fix memory leaks when creating a context.
Author: Peter Pentchev <roam@ringlet.net>
Forwarded: http://libwebsockets.org/trac/ticket/8
Last-Update: 2013-02-07

--- a/lib/libwebsockets.c
+++ b/lib/libwebsockets.c
@@ -1545,6 +1545,7 @@
 		lwsl_err("No memory for websocket context\n");
 		return NULL;
 	}
+	memset(context, 0, sizeof(*context));
 #ifndef LWS_NO_DAEMONIZE
 	extern int pid_daemon;
 	context->started_with_parent = pid_daemon;
@@ -1652,6 +1653,7 @@
 		p = strchr(context->http_proxy_address, ':');
 		if (p == NULL) {
 			lwsl_err("http_proxy needs to be ads:port\n");
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 		*p = '\0';
@@ -1677,6 +1679,7 @@
 		if (ssl_cert_filepath != NULL &&
 					     ssl_private_key_filepath != NULL) {
 			lwsl_notice(" Not compiled for OpenSSl support!\n");
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 		lwsl_notice(" Compiled without SSL support, "
@@ -1715,12 +1718,14 @@
 	if (!method) {
 		lwsl_err("problem creating ssl method: %s\n",
 			ERR_error_string(ERR_get_error(), ssl_err_buf));
+		libwebsocket_context_destroy(context);
 		return NULL;
 	}
 	context->ssl_ctx = SSL_CTX_new(method);	/* create context */
 	if (!context->ssl_ctx) {
 		lwsl_err("problem creating ssl context: %s\n",
 			ERR_error_string(ERR_get_error(), ssl_err_buf));
+		libwebsocket_context_destroy(context);
 		return NULL;
 	}
 
@@ -1739,6 +1744,7 @@
 		if (!method) {
 			lwsl_err("problem creating ssl method: %s\n",
 				ERR_error_string(ERR_get_error(), ssl_err_buf));
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 		/* create context */
@@ -1746,6 +1752,7 @@
 		if (!context->ssl_client_ctx) {
 			lwsl_err("problem creating ssl context: %s\n",
 				ERR_error_string(ERR_get_error(), ssl_err_buf));
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 
@@ -1816,6 +1823,7 @@
 			lwsl_err("problem getting cert '%s': %s\n",
 				ssl_cert_filepath,
 				ERR_error_string(ERR_get_error(), ssl_err_buf));
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 		/* set the private key from KeyFile */
@@ -1824,11 +1832,13 @@
 			lwsl_err("ssl problem getting key '%s': %s\n",
 						ssl_private_key_filepath,
 				ERR_error_string(ERR_get_error(), ssl_err_buf));
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 		/* verify private key */
 		if (!SSL_CTX_check_private_key(context->ssl_ctx)) {
 			lwsl_err("Private SSL key doesn't match cert\n");
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 
@@ -1838,8 +1848,10 @@
 
 	/* selftest */
 
-	if (lws_b64_selftest())
+	if (lws_b64_selftest()) {
+		libwebsocket_context_destroy(context);
 		return NULL;
+	}
 
 #ifndef LWS_NO_SERVER
 	/* set up our external listening socket we serve on */
@@ -1851,6 +1863,7 @@
 		sockfd = socket(AF_INET, SOCK_STREAM, 0);
 		if (sockfd < 0) {
 			lwsl_err("ERROR opening socket\n");
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 
@@ -1880,6 +1893,7 @@
 			lwsl_err("ERROR on binding to port %d (%d %d)\n",
 								port, n, errno);
 			close(sockfd);
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 
@@ -1887,6 +1901,7 @@
 		if (wsi == NULL) {
 			lwsl_err("Out of mem\n");
 			close(sockfd);
+			libwebsocket_context_destroy(context);
 			return NULL;
 		}
 		memset(wsi, 0, sizeof (struct libwebsocket));
